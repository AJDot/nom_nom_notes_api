# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/jwt_sessions/all/jwt_sessions.rbi
#
# jwt_sessions-2.5.2

module JWTSessions
  def access_cookie; end
  def access_cookie=(val); end
  def access_exp_time; end
  def access_exp_time=(val); end
  def access_expiration; end
  def access_header; end
  def access_header=(val); end
  def algorithm; end
  def algorithm=(algo); end
  def cookie_by(token_type); end
  def csrf_header; end
  def csrf_header=(val); end
  def custom_access_expiration(time); end
  def custom_refresh_expiration(time); end
  def encryption_key=(key); end
  def header_by(token_type); end
  def jwt_options; end
  def private_key; end
  def private_key=(val); end
  def public_key; end
  def public_key=(val); end
  def redis_db_name; end
  def redis_db_name=(val); end
  def redis_host; end
  def redis_host=(val); end
  def redis_port; end
  def redis_port=(val); end
  def redis_url; end
  def redis_url=(arg0); end
  def refresh_cookie; end
  def refresh_cookie=(val); end
  def refresh_exp_time; end
  def refresh_exp_time=(val); end
  def refresh_expiration; end
  def refresh_header; end
  def refresh_header=(val); end
  def supported_algos; end
  def token_prefix; end
  def token_prefix=(val); end
  def token_store; end
  def token_store=(args); end
  def validate?; end
  extend JWTSessions
end
module JWTSessions::Errors
end
class JWTSessions::Errors::Error < RuntimeError
end
class JWTSessions::Errors::Malconfigured < JWTSessions::Errors::Error
end
class JWTSessions::Errors::InvalidPayload < JWTSessions::Errors::Error
end
class JWTSessions::Errors::Unauthorized < JWTSessions::Errors::Error
end
class JWTSessions::Errors::ClaimsVerification < JWTSessions::Errors::Unauthorized
end
class JWTSessions::Errors::Expired < JWTSessions::Errors::ClaimsVerification
end
class JWTSessions::Token
  def self.decode!(token); end
  def self.decode(token, claims = nil); end
  def self.encode(payload); end
  def self.meta; end
end
class JWTSessions::RefreshToken
  def access_expiration; end
  def access_uid; end
  def csrf; end
  def destroy; end
  def expiration; end
  def initialize(csrf, access_uid, access_expiration, store, options = nil); end
  def namespace; end
  def persist_in_store; end
  def self.all(namespace, store); end
  def self.build_with_token_attrs(store, uid, token_attrs, namespace); end
  def self.create(csrf, access_uid, access_expiration, store, payload, namespace, expiration = nil); end
  def self.destroy(uid, store, namespace); end
  def self.find(uid, store, namespace = nil, first_match: nil); end
  def store; end
  def token; end
  def uid; end
  def update(access_uid, access_expiration, csrf); end
end
class JWTSessions::CSRFToken
  def encoded; end
  def initialize(csrf_token = nil); end
  def masked_token; end
  def raw_token; end
  def secure_compare(a, b); end
  def token; end
  def unmask_token(masked_token); end
  def valid_authenticity_token?(encoded_masked_token); end
  def xor_byte_strings(s1, s2); end
end
class JWTSessions::AccessToken
  def csrf; end
  def destroy; end
  def expiration; end
  def initialize(csrf, payload, store, uid = nil, expiration = nil); end
  def payload; end
  def refresh_uid; end
  def refresh_uid=(uid); end
  def self.build_with_token_attrs(store, uid, token_attrs); end
  def self.create(csrf, payload, store, expiration = nil); end
  def self.destroy(uid, store); end
  def self.find(uid, store); end
  def store; end
  def token; end
  def uid; end
end
class JWTSessions::Session
  def access_token; end
  def access_token_data(token, _first_match = nil); end
  def check_access_uid_within_refresh_token; end
  def check_refresh_on_time; end
  def create_access_token; end
  def create_csrf_token; end
  def create_refresh_token; end
  def csrf(access_token); end
  def csrf_token; end
  def flush_by_access_payload; end
  def flush_by_token(token); end
  def flush_by_uid(uid); end
  def flush_namespaced; end
  def flush_namespaced_access_tokens; end
  def initialize(options = nil); end
  def issue_tokens_after_refresh; end
  def link_access_to_refresh; end
  def login; end
  def masked_csrf(access_token); end
  def namespace; end
  def namespace=(arg0); end
  def payload; end
  def payload=(arg0); end
  def refresh(refresh_token, &block); end
  def refresh_by_access_allowed; end
  def refresh_by_access_allowed=(arg0); end
  def refresh_by_access_payload(&block); end
  def refresh_by_uid(&block); end
  def refresh_csrf(refresh_token); end
  def refresh_payload; end
  def refresh_payload=(arg0); end
  def refresh_token; end
  def refresh_token_data(token, first_match = nil); end
  def refresh_tokens_hash; end
  def retrieve_refresh_token(uid, first_match: nil); end
  def retrieve_val_from(token_payload, type, val_key, val_name); end
  def self.flush_all(store = nil); end
  def session_exists?(token, token_type = nil); end
  def store; end
  def store=(arg0); end
  def token_uid(token, type, claims); end
  def tokens_hash; end
  def update_refresh_token; end
  def valid_access_csrf?(access_token, csrf_token); end
  def valid_access_request?(external_csrf_token, external_payload); end
  def valid_csrf?(token, csrf_token, token_type = nil); end
  def valid_refresh_csrf?(refresh_token, csrf_token); end
end
module JWTSessions::Authorization
  def authorize_access_request!; end
  def authorize_by_access_cookie!; end
  def authorize_by_access_header!; end
  def authorize_by_refresh_cookie!; end
  def authorize_by_refresh_header!; end
  def authorize_refresh_by_access_cookie!; end
  def authorize_refresh_by_access_header!; end
  def authorize_refresh_by_access_request!; end
  def authorize_refresh_request!; end
  def authorize_request(token_type); end
  def check_csrf(token_type); end
  def claimless_payload; end
  def cookie_based_auth(token_type); end
  def cookieless_auth(token_type); end
  def found_token; end
  def invalid_authorization; end
  def payload; end
  def refresh_by_access_invalid?; end
  def request_cookies; end
  def request_headers; end
  def request_method; end
  def retrieve_csrf; end
  def session_exists?(token_type); end
  def should_check_csrf?; end
  def token_from_cookies(token_type); end
  def token_from_headers(token_type); end
  def valid_csrf_token?(csrf_token, token_type); end
end
module JWTSessions::RailsAuthorization
  def request_cookies; end
  def request_headers; end
  def request_method; end
  include JWTSessions::Authorization
end
module JWTSessions::StoreAdapters
  def self.build_by_name(adapter, options = nil); end
end
class JWTSessions::StoreAdapters::AbstractStoreAdapter
  def all_refresh_tokens(_namespace); end
  def destroy_access(_uid); end
  def destroy_refresh(_uid, _namespace); end
  def fetch_access(_uid); end
  def fetch_refresh(_uid, _namespace, _first_match); end
  def persist_access(_uid, _csrf, _expiration); end
  def persist_refresh(_uid:, _access_expiration:, _access_uid:, _csrf:, _expiration:, _namespace:); end
  def update_refresh(_uid:, _access_expiration:, _access_uid:, _csrf:, _namespace:); end
end
class JWTSessions::StoreAdapters::RedisStoreAdapter < JWTSessions::StoreAdapters::AbstractStoreAdapter
  def access_key(uid); end
  def all_refresh_tokens(namespace); end
  def build_redis_url(redis_host: nil, redis_port: nil, redis_db_name: nil); end
  def configure_redis_client(redis_url: nil, redis_host: nil, redis_port: nil, redis_db_name: nil); end
  def destroy_access(uid); end
  def destroy_refresh(uid, namespace); end
  def fetch_access(uid); end
  def fetch_refresh(uid, namespace, first_match = nil); end
  def first_refresh_key(uid); end
  def full_refresh_key(uid, namespace); end
  def initialize(token_prefix: nil, **options); end
  def persist_access(uid, csrf, expiration); end
  def persist_refresh(uid:, access_expiration:, access_uid:, csrf:, expiration:, namespace: nil); end
  def prefix; end
  def refresh_key(uid, namespace); end
  def storage; end
  def uid_from_key(key); end
  def update_refresh(uid:, access_expiration:, access_uid:, csrf:, namespace: nil); end
end
class JWTSessions::StoreAdapters::MemoryStoreAdapter < JWTSessions::StoreAdapters::AbstractStoreAdapter
  def all_refresh_tokens(namespace); end
  def destroy_access(uid); end
  def destroy_refresh(uid, namespace); end
  def fetch_access(uid); end
  def fetch_refresh(uid, namespace, first_match = nil); end
  def initialize(**options); end
  def persist_access(uid, csrf, expiration); end
  def persist_refresh(uid:, access_expiration:, access_uid:, csrf:, expiration:, namespace: nil); end
  def select_keys(keys_hash, acc); end
  def storage; end
  def update_refresh(uid:, access_expiration:, access_uid:, csrf:, namespace: nil); end
  def update_refresh_fields(key, namespace, fields); end
  def value_if_not_expired(key, token_type, namespace); end
end
class JWTSessions::JWTOptions < Struct
  def algorithms; end
  def algorithms=(_); end
  def leeway; end
  def leeway=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def verify_aud; end
  def verify_aud=(_); end
  def verify_expiration; end
  def verify_expiration=(_); end
  def verify_iat; end
  def verify_iat=(_); end
  def verify_iss; end
  def verify_iss=(_); end
  def verify_jti; end
  def verify_jti=(_); end
  def verify_not_before; end
  def verify_not_before=(_); end
  def verify_sub; end
  def verify_sub=(_); end
end
